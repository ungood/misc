
1281_boot.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000002  00800200  0000097e  00000a12  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000097e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000000d  00800202  00800202  00000a14  2**0
                  ALLOC
  3 .stab         00001d88  00000000  00000000  00000a14  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000f69  00000000  00000000  0000279c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 d2 00 	jmp	0x1a4	; 0x1a4 <__ctors_end>
   4:	0c 94 29 01 	jmp	0x252	; 0x252 <__vector_1>
   8:	0c 94 5a 01 	jmp	0x2b4	; 0x2b4 <__vector_2>
   c:	0c 94 f1 00 	jmp	0x1e2	; 0x1e2 <__bad_interrupt>
  10:	0c 94 f1 00 	jmp	0x1e2	; 0x1e2 <__bad_interrupt>
  14:	0c 94 f1 00 	jmp	0x1e2	; 0x1e2 <__bad_interrupt>
  18:	0c 94 f1 00 	jmp	0x1e2	; 0x1e2 <__bad_interrupt>
  1c:	0c 94 f1 00 	jmp	0x1e2	; 0x1e2 <__bad_interrupt>
  20:	0c 94 f1 00 	jmp	0x1e2	; 0x1e2 <__bad_interrupt>
  24:	0c 94 f1 00 	jmp	0x1e2	; 0x1e2 <__bad_interrupt>
  28:	0c 94 f1 00 	jmp	0x1e2	; 0x1e2 <__bad_interrupt>
  2c:	0c 94 f1 00 	jmp	0x1e2	; 0x1e2 <__bad_interrupt>
  30:	0c 94 f1 00 	jmp	0x1e2	; 0x1e2 <__bad_interrupt>
  34:	0c 94 f1 00 	jmp	0x1e2	; 0x1e2 <__bad_interrupt>
  38:	0c 94 f1 00 	jmp	0x1e2	; 0x1e2 <__bad_interrupt>
  3c:	0c 94 f1 00 	jmp	0x1e2	; 0x1e2 <__bad_interrupt>
  40:	0c 94 f1 00 	jmp	0x1e2	; 0x1e2 <__bad_interrupt>
  44:	0c 94 f1 00 	jmp	0x1e2	; 0x1e2 <__bad_interrupt>
  48:	0c 94 f1 00 	jmp	0x1e2	; 0x1e2 <__bad_interrupt>
  4c:	0c 94 f1 00 	jmp	0x1e2	; 0x1e2 <__bad_interrupt>
  50:	0c 94 f1 00 	jmp	0x1e2	; 0x1e2 <__bad_interrupt>
  54:	0c 94 f1 00 	jmp	0x1e2	; 0x1e2 <__bad_interrupt>
  58:	0c 94 f1 00 	jmp	0x1e2	; 0x1e2 <__bad_interrupt>
  5c:	0c 94 8c 01 	jmp	0x318	; 0x318 <__vector_23>
  60:	0c 94 f1 00 	jmp	0x1e2	; 0x1e2 <__bad_interrupt>
  64:	0c 94 f1 00 	jmp	0x1e2	; 0x1e2 <__bad_interrupt>
  68:	0c 94 f1 00 	jmp	0x1e2	; 0x1e2 <__bad_interrupt>
  6c:	0c 94 f1 00 	jmp	0x1e2	; 0x1e2 <__bad_interrupt>
  70:	0c 94 f1 00 	jmp	0x1e2	; 0x1e2 <__bad_interrupt>
  74:	0c 94 f1 00 	jmp	0x1e2	; 0x1e2 <__bad_interrupt>
  78:	0c 94 f1 00 	jmp	0x1e2	; 0x1e2 <__bad_interrupt>
  7c:	0c 94 f1 00 	jmp	0x1e2	; 0x1e2 <__bad_interrupt>
  80:	0c 94 f1 00 	jmp	0x1e2	; 0x1e2 <__bad_interrupt>
  84:	0c 94 f1 00 	jmp	0x1e2	; 0x1e2 <__bad_interrupt>
  88:	0c 94 f1 00 	jmp	0x1e2	; 0x1e2 <__bad_interrupt>
  8c:	0c 94 f1 00 	jmp	0x1e2	; 0x1e2 <__bad_interrupt>
  90:	0c 94 f1 00 	jmp	0x1e2	; 0x1e2 <__bad_interrupt>
  94:	0c 94 f1 00 	jmp	0x1e2	; 0x1e2 <__bad_interrupt>
  98:	0c 94 f1 00 	jmp	0x1e2	; 0x1e2 <__bad_interrupt>
  9c:	0c 94 f1 00 	jmp	0x1e2	; 0x1e2 <__bad_interrupt>
  a0:	0c 94 f1 00 	jmp	0x1e2	; 0x1e2 <__bad_interrupt>
  a4:	0c 94 f1 00 	jmp	0x1e2	; 0x1e2 <__bad_interrupt>
  a8:	0c 94 f1 00 	jmp	0x1e2	; 0x1e2 <__bad_interrupt>
  ac:	0c 94 f1 00 	jmp	0x1e2	; 0x1e2 <__bad_interrupt>
  b0:	0c 94 f1 00 	jmp	0x1e2	; 0x1e2 <__bad_interrupt>
  b4:	0c 94 f1 00 	jmp	0x1e2	; 0x1e2 <__bad_interrupt>
  b8:	0c 94 f1 00 	jmp	0x1e2	; 0x1e2 <__bad_interrupt>
  bc:	0c 94 f1 00 	jmp	0x1e2	; 0x1e2 <__bad_interrupt>
  c0:	0c 94 f1 00 	jmp	0x1e2	; 0x1e2 <__bad_interrupt>
  c4:	0c 94 f1 00 	jmp	0x1e2	; 0x1e2 <__bad_interrupt>
  c8:	0c 94 f1 00 	jmp	0x1e2	; 0x1e2 <__bad_interrupt>

000000cc <port_to_mode_PGM>:
  cc:	00 00 21 00 24 00 27 00 2a 00 2d 00 30 00 33 00     ..!.$.'.*.-.0.3.

000000dc <port_to_output_PGM>:
  dc:	00 00 22 00 25 00 28 00 2b 00 2e 00 31 00 34 00     ..".%.(.+...1.4.

000000ec <port_to_input_PGM>:
  ec:	00 00 20 00 23 00 26 00 29 00 2c 00 2f 00 32 00     .. .#.&.).,./.2.

000000fc <digital_pin_to_port_PGM>:
  fc:	05 05 04 04 04 04 04 04 05 05 07 05 02 02 02 02     ................
 10c:	01 01 01 01 01 01 01 01 03 03 03 03 03 03 03 03     ................
 11c:	05 05 05 04 04 04 04 07 07 07 07 07 02 02 02 02     ................
 12c:	06 06 06 06 06 06 06 06                             ........

00000134 <digital_pin_to_bit_mask_PGM>:
 134:	01 02 04 08 02 01 01 02 10 20 20 08 10 20 40 80     .........  .. @.
 144:	01 02 04 08 10 20 40 80 01 02 04 08 10 20 40 80     ..... @...... @.
 154:	04 40 80 10 20 40 80 01 02 04 08 10 01 02 04 08     .@.. @..........
 164:	01 02 04 08 10 20 40 80                             ..... @.

0000016c <digital_pin_to_timer_PGM>:
	...
 174:	09 0a 02 08 06 03 04 01 00 00 00 00 00 00 00 00     ................
	...

000001a4 <__ctors_end>:
 1a4:	11 24       	eor	r1, r1
 1a6:	1f be       	out	0x3f, r1	; 63
 1a8:	cf ef       	ldi	r28, 0xFF	; 255
 1aa:	d1 e2       	ldi	r29, 0x21	; 33
 1ac:	de bf       	out	0x3e, r29	; 62
 1ae:	cd bf       	out	0x3d, r28	; 61

000001b0 <__do_copy_data>:
 1b0:	12 e0       	ldi	r17, 0x02	; 2
 1b2:	a0 e0       	ldi	r26, 0x00	; 0
 1b4:	b2 e0       	ldi	r27, 0x02	; 2
 1b6:	ee e7       	ldi	r30, 0x7E	; 126
 1b8:	f9 e0       	ldi	r31, 0x09	; 9
 1ba:	00 e0       	ldi	r16, 0x00	; 0
 1bc:	0b bf       	out	0x3b, r16	; 59
 1be:	02 c0       	rjmp	.+4      	; 0x1c4 <__do_copy_data+0x14>
 1c0:	07 90       	elpm	r0, Z+
 1c2:	0d 92       	st	X+, r0
 1c4:	a2 30       	cpi	r26, 0x02	; 2
 1c6:	b1 07       	cpc	r27, r17
 1c8:	d9 f7       	brne	.-10     	; 0x1c0 <__do_copy_data+0x10>

000001ca <__do_clear_bss>:
 1ca:	12 e0       	ldi	r17, 0x02	; 2
 1cc:	a2 e0       	ldi	r26, 0x02	; 2
 1ce:	b2 e0       	ldi	r27, 0x02	; 2
 1d0:	01 c0       	rjmp	.+2      	; 0x1d4 <.do_clear_bss_start>

000001d2 <.do_clear_bss_loop>:
 1d2:	1d 92       	st	X+, r1

000001d4 <.do_clear_bss_start>:
 1d4:	af 30       	cpi	r26, 0x0F	; 15
 1d6:	b1 07       	cpc	r27, r17
 1d8:	e1 f7       	brne	.-8      	; 0x1d2 <.do_clear_bss_loop>
 1da:	0e 94 8b 01 	call	0x316	; 0x316 <main>
 1de:	0c 94 bd 04 	jmp	0x97a	; 0x97a <_exit>

000001e2 <__bad_interrupt>:
 1e2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000001e6 <attachInterrupt>:
#define EICRA MCUCR
#define EIMSK GICR
#endif

void attachInterrupt(uint8_t interruptNum, void (*userFunc)(void), int mode) {
  if(interruptNum < EXTERNAL_NUM_INTERRUPTS) {
 1e6:	82 30       	cpi	r24, 0x02	; 2
 1e8:	08 f0       	brcs	.+2      	; 0x1ec <attachInterrupt+0x6>
 1ea:	08 95       	ret
    intFunc[interruptNum] = userFunc;
 1ec:	e8 2f       	mov	r30, r24
 1ee:	f0 e0       	ldi	r31, 0x00	; 0
 1f0:	ee 0f       	add	r30, r30
 1f2:	ff 1f       	adc	r31, r31
 1f4:	ee 5f       	subi	r30, 0xFE	; 254
 1f6:	fd 4f       	sbci	r31, 0xFD	; 253
 1f8:	71 83       	std	Z+1, r23	; 0x01
 1fa:	60 83       	st	Z, r22
    // to the configuration bits in the hardware register, so we simply shift
    // the mode into place.
      
    // Enable the interrupt.
      
    switch (interruptNum) {
 1fc:	88 23       	and	r24, r24
 1fe:	41 f4       	brne	.+16     	; 0x210 <attachInterrupt+0x2a>
      EICRB = (EICRB & ~((1 << ISC70) | (1 << ISC71))) | (mode << ISC70);
      EIMSK |= (1 << INT7);
      break;
#else
    case 0:
      EICRA = (EICRA & ~((1 << ISC00) | (1 << ISC01))) | (mode << ISC00);
 200:	80 91 69 00 	lds	r24, 0x0069
 204:	8c 7f       	andi	r24, 0xFC	; 252
 206:	84 2b       	or	r24, r20
 208:	80 93 69 00 	sts	0x0069, r24
      EIMSK |= (1 << INT0);
 20c:	e8 9a       	sbi	0x1d, 0	; 29
 20e:	08 95       	ret
    // to the configuration bits in the hardware register, so we simply shift
    // the mode into place.
      
    // Enable the interrupt.
      
    switch (interruptNum) {
 210:	81 30       	cpi	r24, 0x01	; 1
 212:	59 f7       	brne	.-42     	; 0x1ea <attachInterrupt+0x4>
    case 0:
      EICRA = (EICRA & ~((1 << ISC00) | (1 << ISC01))) | (mode << ISC00);
      EIMSK |= (1 << INT0);
      break;
    case 1:
      EICRA = (EICRA & ~((1 << ISC10) | (1 << ISC11))) | (mode << ISC10);
 214:	80 91 69 00 	lds	r24, 0x0069
 218:	44 0f       	add	r20, r20
 21a:	55 1f       	adc	r21, r21
 21c:	44 0f       	add	r20, r20
 21e:	55 1f       	adc	r21, r21
 220:	83 7f       	andi	r24, 0xF3	; 243
 222:	84 2b       	or	r24, r20
 224:	80 93 69 00 	sts	0x0069, r24
      EIMSK |= (1 << INT1);
 228:	e9 9a       	sbi	0x1d, 1	; 29
 22a:	08 95       	ret

0000022c <detachInterrupt>:
    }
  }
}

void detachInterrupt(uint8_t interruptNum) {
  if(interruptNum < EXTERNAL_NUM_INTERRUPTS) {
 22c:	82 30       	cpi	r24, 0x02	; 2
 22e:	08 f0       	brcs	.+2      	; 0x232 <detachInterrupt+0x6>
 230:	08 95       	ret
    // Disable the interrupt.  (We can't assume that interruptNum is equal
    // to the number of the EIMSK bit to clear, as this isn't true on the 
    // ATmega8.  There, INT0 is 6 and INT1 is 7.)
    switch (interruptNum) {
 232:	88 23       	and	r24, r24
 234:	61 f0       	breq	.+24     	; 0x24e <detachInterrupt+0x22>
 236:	81 30       	cpi	r24, 0x01	; 1
 238:	09 f4       	brne	.+2      	; 0x23c <detachInterrupt+0x10>
#else
    case 0:
      EIMSK &= ~(1 << INT0);
      break;
    case 1:
      EIMSK &= ~(1 << INT1);
 23a:	e9 98       	cbi	0x1d, 1	; 29
      break;
#endif
    }
      
    intFunc[interruptNum] = 0;
 23c:	e8 2f       	mov	r30, r24
 23e:	f0 e0       	ldi	r31, 0x00	; 0
 240:	ee 0f       	add	r30, r30
 242:	ff 1f       	adc	r31, r31
 244:	ee 5f       	subi	r30, 0xFE	; 254
 246:	fd 4f       	sbci	r31, 0xFD	; 253
 248:	11 82       	std	Z+1, r1	; 0x01
 24a:	10 82       	st	Z, r1
 24c:	08 95       	ret
    case 7:
      EIMSK &= ~(1 << INT7);
      break;
#else
    case 0:
      EIMSK &= ~(1 << INT0);
 24e:	e8 98       	cbi	0x1d, 0	; 29
 250:	f5 cf       	rjmp	.-22     	; 0x23c <detachInterrupt+0x10>

00000252 <__vector_1>:
    intFunc[EXTERNAL_INT_7]();
}

#else

SIGNAL(INT0_vect) {
 252:	1f 92       	push	r1
 254:	0f 92       	push	r0
 256:	0f b6       	in	r0, 0x3f	; 63
 258:	0f 92       	push	r0
 25a:	0b b6       	in	r0, 0x3b	; 59
 25c:	0f 92       	push	r0
 25e:	11 24       	eor	r1, r1
 260:	2f 93       	push	r18
 262:	3f 93       	push	r19
 264:	4f 93       	push	r20
 266:	5f 93       	push	r21
 268:	6f 93       	push	r22
 26a:	7f 93       	push	r23
 26c:	8f 93       	push	r24
 26e:	9f 93       	push	r25
 270:	af 93       	push	r26
 272:	bf 93       	push	r27
 274:	ef 93       	push	r30
 276:	ff 93       	push	r31
  if(intFunc[EXTERNAL_INT_0])
 278:	80 91 02 02 	lds	r24, 0x0202
 27c:	90 91 03 02 	lds	r25, 0x0203
 280:	89 2b       	or	r24, r25
 282:	29 f0       	breq	.+10     	; 0x28e <__vector_1+0x3c>
    intFunc[EXTERNAL_INT_0]();
 284:	e0 91 02 02 	lds	r30, 0x0202
 288:	f0 91 03 02 	lds	r31, 0x0203
 28c:	09 95       	icall
}
 28e:	ff 91       	pop	r31
 290:	ef 91       	pop	r30
 292:	bf 91       	pop	r27
 294:	af 91       	pop	r26
 296:	9f 91       	pop	r25
 298:	8f 91       	pop	r24
 29a:	7f 91       	pop	r23
 29c:	6f 91       	pop	r22
 29e:	5f 91       	pop	r21
 2a0:	4f 91       	pop	r20
 2a2:	3f 91       	pop	r19
 2a4:	2f 91       	pop	r18
 2a6:	0f 90       	pop	r0
 2a8:	0b be       	out	0x3b, r0	; 59
 2aa:	0f 90       	pop	r0
 2ac:	0f be       	out	0x3f, r0	; 63
 2ae:	0f 90       	pop	r0
 2b0:	1f 90       	pop	r1
 2b2:	18 95       	reti

000002b4 <__vector_2>:

SIGNAL(INT1_vect) {
 2b4:	1f 92       	push	r1
 2b6:	0f 92       	push	r0
 2b8:	0f b6       	in	r0, 0x3f	; 63
 2ba:	0f 92       	push	r0
 2bc:	0b b6       	in	r0, 0x3b	; 59
 2be:	0f 92       	push	r0
 2c0:	11 24       	eor	r1, r1
 2c2:	2f 93       	push	r18
 2c4:	3f 93       	push	r19
 2c6:	4f 93       	push	r20
 2c8:	5f 93       	push	r21
 2ca:	6f 93       	push	r22
 2cc:	7f 93       	push	r23
 2ce:	8f 93       	push	r24
 2d0:	9f 93       	push	r25
 2d2:	af 93       	push	r26
 2d4:	bf 93       	push	r27
 2d6:	ef 93       	push	r30
 2d8:	ff 93       	push	r31
  if(intFunc[EXTERNAL_INT_1])
 2da:	80 91 04 02 	lds	r24, 0x0204
 2de:	90 91 05 02 	lds	r25, 0x0205
 2e2:	89 2b       	or	r24, r25
 2e4:	29 f0       	breq	.+10     	; 0x2f0 <__vector_2+0x3c>
    intFunc[EXTERNAL_INT_1]();
 2e6:	e0 91 04 02 	lds	r30, 0x0204
 2ea:	f0 91 05 02 	lds	r31, 0x0205
 2ee:	09 95       	icall
}
 2f0:	ff 91       	pop	r31
 2f2:	ef 91       	pop	r30
 2f4:	bf 91       	pop	r27
 2f6:	af 91       	pop	r26
 2f8:	9f 91       	pop	r25
 2fa:	8f 91       	pop	r24
 2fc:	7f 91       	pop	r23
 2fe:	6f 91       	pop	r22
 300:	5f 91       	pop	r21
 302:	4f 91       	pop	r20
 304:	3f 91       	pop	r19
 306:	2f 91       	pop	r18
 308:	0f 90       	pop	r0
 30a:	0b be       	out	0x3b, r0	; 59
 30c:	0f 90       	pop	r0
 30e:	0f be       	out	0x3f, r0	; 63
 310:	0f 90       	pop	r0
 312:	1f 90       	pop	r1
 314:	18 95       	reti

00000316 <main>:
int main(void)
{
 316:	ff cf       	rjmp	.-2      	; 0x316 <main>

00000318 <__vector_23>:
volatile unsigned long timer0_overflow_count = 0;
volatile unsigned long timer0_millis = 0;
static unsigned char timer0_fract = 0;

SIGNAL(TIMER0_OVF_vect)
{
 318:	1f 92       	push	r1
 31a:	0f 92       	push	r0
 31c:	0f b6       	in	r0, 0x3f	; 63
 31e:	0f 92       	push	r0
 320:	11 24       	eor	r1, r1
 322:	2f 93       	push	r18
 324:	3f 93       	push	r19
 326:	8f 93       	push	r24
 328:	9f 93       	push	r25
 32a:	af 93       	push	r26
 32c:	bf 93       	push	r27
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
 32e:	80 91 0a 02 	lds	r24, 0x020A
 332:	90 91 0b 02 	lds	r25, 0x020B
 336:	a0 91 0c 02 	lds	r26, 0x020C
 33a:	b0 91 0d 02 	lds	r27, 0x020D
	unsigned char f = timer0_fract;
 33e:	30 91 0e 02 	lds	r19, 0x020E

	m += MILLIS_INC;
 342:	01 96       	adiw	r24, 0x01	; 1
 344:	a1 1d       	adc	r26, r1
 346:	b1 1d       	adc	r27, r1
	f += FRACT_INC;
 348:	23 2f       	mov	r18, r19
 34a:	2d 5f       	subi	r18, 0xFD	; 253
	if (f >= FRACT_MAX) {
 34c:	2d 37       	cpi	r18, 0x7D	; 125
 34e:	20 f0       	brcs	.+8      	; 0x358 <__vector_23+0x40>
		f -= FRACT_MAX;
 350:	2d 57       	subi	r18, 0x7D	; 125
		m += 1;
 352:	01 96       	adiw	r24, 0x01	; 1
 354:	a1 1d       	adc	r26, r1
 356:	b1 1d       	adc	r27, r1
	}

	timer0_fract = f;
 358:	20 93 0e 02 	sts	0x020E, r18
	timer0_millis = m;
 35c:	80 93 0a 02 	sts	0x020A, r24
 360:	90 93 0b 02 	sts	0x020B, r25
 364:	a0 93 0c 02 	sts	0x020C, r26
 368:	b0 93 0d 02 	sts	0x020D, r27
	timer0_overflow_count++;
 36c:	80 91 06 02 	lds	r24, 0x0206
 370:	90 91 07 02 	lds	r25, 0x0207
 374:	a0 91 08 02 	lds	r26, 0x0208
 378:	b0 91 09 02 	lds	r27, 0x0209
 37c:	01 96       	adiw	r24, 0x01	; 1
 37e:	a1 1d       	adc	r26, r1
 380:	b1 1d       	adc	r27, r1
 382:	80 93 06 02 	sts	0x0206, r24
 386:	90 93 07 02 	sts	0x0207, r25
 38a:	a0 93 08 02 	sts	0x0208, r26
 38e:	b0 93 09 02 	sts	0x0209, r27
}
 392:	bf 91       	pop	r27
 394:	af 91       	pop	r26
 396:	9f 91       	pop	r25
 398:	8f 91       	pop	r24
 39a:	3f 91       	pop	r19
 39c:	2f 91       	pop	r18
 39e:	0f 90       	pop	r0
 3a0:	0f be       	out	0x3f, r0	; 63
 3a2:	0f 90       	pop	r0
 3a4:	1f 90       	pop	r1
 3a6:	18 95       	reti

000003a8 <millis>:

unsigned long millis()
{
	unsigned long m;
	uint8_t oldSREG = SREG;
 3a8:	8f b7       	in	r24, 0x3f	; 63

	// disable interrupts while we read timer0_millis or we might get an
	// inconsistent value (e.g. in the middle of a write to timer0_millis)
	cli();
 3aa:	f8 94       	cli
	m = timer0_millis;
 3ac:	20 91 0a 02 	lds	r18, 0x020A
 3b0:	30 91 0b 02 	lds	r19, 0x020B
 3b4:	40 91 0c 02 	lds	r20, 0x020C
 3b8:	50 91 0d 02 	lds	r21, 0x020D
	SREG = oldSREG;
 3bc:	8f bf       	out	0x3f, r24	; 63

	return m;
}
 3be:	b9 01       	movw	r22, r18
 3c0:	ca 01       	movw	r24, r20
 3c2:	08 95       	ret

000003c4 <micros>:

unsigned long micros() {
	unsigned long m, t;
	uint8_t oldSREG = SREG;
 3c4:	6f b7       	in	r22, 0x3f	; 63
	
	cli();	
 3c6:	f8 94       	cli
	t = TCNT0;
 3c8:	86 b5       	in	r24, 0x26	; 38
 3ca:	90 e0       	ldi	r25, 0x00	; 0
 3cc:	a0 e0       	ldi	r26, 0x00	; 0
 3ce:	b0 e0       	ldi	r27, 0x00	; 0
  
#ifdef TIFR0
	if ((TIFR0 & _BV(TOV0)) && (t == 0))
 3d0:	a8 9b       	sbis	0x15, 0	; 21
 3d2:	08 c0       	rjmp	.+16     	; 0x3e4 <micros+0x20>
 3d4:	00 97       	sbiw	r24, 0x00	; 0
 3d6:	a1 05       	cpc	r26, r1
 3d8:	b1 05       	cpc	r27, r1
 3da:	21 f4       	brne	.+8      	; 0x3e4 <micros+0x20>
 3dc:	80 e0       	ldi	r24, 0x00	; 0
 3de:	91 e0       	ldi	r25, 0x01	; 1
 3e0:	a0 e0       	ldi	r26, 0x00	; 0
 3e2:	b0 e0       	ldi	r27, 0x00	; 0
#else
	if ((TIFR & _BV(TOV0)) && (t == 0))
		t = 256;
#endif

	m = timer0_overflow_count;
 3e4:	20 91 06 02 	lds	r18, 0x0206
 3e8:	30 91 07 02 	lds	r19, 0x0207
 3ec:	40 91 08 02 	lds	r20, 0x0208
 3f0:	50 91 09 02 	lds	r21, 0x0209
	SREG = oldSREG;
 3f4:	6f bf       	out	0x3f, r22	; 63
 3f6:	54 2f       	mov	r21, r20
 3f8:	43 2f       	mov	r20, r19
 3fa:	32 2f       	mov	r19, r18
 3fc:	22 27       	eor	r18, r18
 3fe:	28 0f       	add	r18, r24
 400:	39 1f       	adc	r19, r25
 402:	4a 1f       	adc	r20, r26
 404:	5b 1f       	adc	r21, r27
 406:	22 0f       	add	r18, r18
 408:	33 1f       	adc	r19, r19
 40a:	44 1f       	adc	r20, r20
 40c:	55 1f       	adc	r21, r21
 40e:	22 0f       	add	r18, r18
 410:	33 1f       	adc	r19, r19
 412:	44 1f       	adc	r20, r20
 414:	55 1f       	adc	r21, r21
	
	return ((m << 8) + t) * (64 / clockCyclesPerMicrosecond());
}
 416:	b9 01       	movw	r22, r18
 418:	ca 01       	movw	r24, r20
 41a:	08 95       	ret

0000041c <delay>:

void delay(unsigned long ms)
{
 41c:	ef 92       	push	r14
 41e:	ff 92       	push	r15
 420:	0f 93       	push	r16
 422:	1f 93       	push	r17
 424:	7b 01       	movw	r14, r22
 426:	8c 01       	movw	r16, r24
}

unsigned long millis()
{
	unsigned long m;
	uint8_t oldSREG = SREG;
 428:	8f b7       	in	r24, 0x3f	; 63

	// disable interrupts while we read timer0_millis or we might get an
	// inconsistent value (e.g. in the middle of a write to timer0_millis)
	cli();
 42a:	f8 94       	cli
	m = timer0_millis;
 42c:	40 91 0a 02 	lds	r20, 0x020A
 430:	50 91 0b 02 	lds	r21, 0x020B
 434:	60 91 0c 02 	lds	r22, 0x020C
 438:	70 91 0d 02 	lds	r23, 0x020D
	SREG = oldSREG;
 43c:	8f bf       	out	0x3f, r24	; 63
}

unsigned long millis()
{
	unsigned long m;
	uint8_t oldSREG = SREG;
 43e:	2f b7       	in	r18, 0x3f	; 63

	// disable interrupts while we read timer0_millis or we might get an
	// inconsistent value (e.g. in the middle of a write to timer0_millis)
	cli();
 440:	f8 94       	cli
	m = timer0_millis;
 442:	80 91 0a 02 	lds	r24, 0x020A
 446:	90 91 0b 02 	lds	r25, 0x020B
 44a:	a0 91 0c 02 	lds	r26, 0x020C
 44e:	b0 91 0d 02 	lds	r27, 0x020D
	SREG = oldSREG;
 452:	2f bf       	out	0x3f, r18	; 63

void delay(unsigned long ms)
{
	unsigned long start = millis();
	
	while (millis() - start <= ms)
 454:	84 1b       	sub	r24, r20
 456:	95 0b       	sbc	r25, r21
 458:	a6 0b       	sbc	r26, r22
 45a:	b7 0b       	sbc	r27, r23
 45c:	e8 16       	cp	r14, r24
 45e:	f9 06       	cpc	r15, r25
 460:	0a 07       	cpc	r16, r26
 462:	1b 07       	cpc	r17, r27
 464:	60 f7       	brcc	.-40     	; 0x43e <delay+0x22>
		;
}
 466:	1f 91       	pop	r17
 468:	0f 91       	pop	r16
 46a:	ff 90       	pop	r15
 46c:	ef 90       	pop	r14
 46e:	08 95       	ret

00000470 <delayMicroseconds>:
#if F_CPU >= 16000000L
	// for the 16 MHz clock on most Arduino boards

	// for a one-microsecond delay, simply return.  the overhead
	// of the function call yields a delay of approximately 1 1/8 us.
	if (--us == 0)
 470:	01 97       	sbiw	r24, 0x01	; 1
 472:	59 f0       	breq	.+22     	; 0x48a <delayMicroseconds+0x1a>
		return;

	// the following loop takes a quarter of a microsecond (4 cycles)
	// per iteration, so execute it four times for each microsecond of
	// delay requested.
	us <<= 2;
 474:	fc 01       	movw	r30, r24
 476:	ee 0f       	add	r30, r30
 478:	ff 1f       	adc	r31, r31
 47a:	ee 0f       	add	r30, r30
 47c:	ff 1f       	adc	r31, r31

	// account for the time taken in the preceeding commands.
	us -= 2;
 47e:	32 97       	sbiw	r30, 0x02	; 2
	us--;
#endif

	// disable interrupts, otherwise the timer 0 overflow interrupt that
	// tracks milliseconds will make us delay longer than we want.
	oldSREG = SREG;
 480:	8f b7       	in	r24, 0x3f	; 63
	cli();
 482:	f8 94       	cli

	// busy wait
	__asm__ __volatile__ (
 484:	31 97       	sbiw	r30, 0x01	; 1
 486:	f1 f7       	brne	.-4      	; 0x484 <delayMicroseconds+0x14>
		"1: sbiw %0,1" "\n\t" // 2 cycles
		"brne 1b" : "=w" (us) : "0" (us) // 2 cycles
	);

	// reenable interrupts.
	SREG = oldSREG;
 488:	8f bf       	out	0x3f, r24	; 63
 48a:	08 95       	ret

0000048c <init>:

void init()
{
	// this needs to be called before setup() or some functions won't
	// work there
	sei();
 48c:	78 94       	sei
	
	// on the ATmega168, timer 0 is also used for fast hardware pwm
	// (using phase-correct PWM would mean that timer 0 overflowed half as often
	// resulting in different millis() behavior on the ATmega8 and ATmega168)
#if !defined(__AVR_ATmega8__)
	sbi(TCCR0A, WGM01);
 48e:	84 b5       	in	r24, 0x24	; 36
 490:	82 60       	ori	r24, 0x02	; 2
 492:	84 bd       	out	0x24, r24	; 36
	sbi(TCCR0A, WGM00);
 494:	84 b5       	in	r24, 0x24	; 36
 496:	81 60       	ori	r24, 0x01	; 1
 498:	84 bd       	out	0x24, r24	; 36
	// set timer 0 prescale factor to 64
#if defined(__AVR_ATmega8__)
	sbi(TCCR0, CS01);
	sbi(TCCR0, CS00);
#else
	sbi(TCCR0B, CS01);
 49a:	85 b5       	in	r24, 0x25	; 37
 49c:	82 60       	ori	r24, 0x02	; 2
 49e:	85 bd       	out	0x25, r24	; 37
	sbi(TCCR0B, CS00);
 4a0:	85 b5       	in	r24, 0x25	; 37
 4a2:	81 60       	ori	r24, 0x01	; 1
 4a4:	85 bd       	out	0x25, r24	; 37
#endif
	// enable timer 0 overflow interrupt
#if defined(__AVR_ATmega8__)
	sbi(TIMSK, TOIE0);
#else
	sbi(TIMSK0, TOIE0);
 4a6:	ee e6       	ldi	r30, 0x6E	; 110
 4a8:	f0 e0       	ldi	r31, 0x00	; 0
 4aa:	80 81       	ld	r24, Z
 4ac:	81 60       	ori	r24, 0x01	; 1
 4ae:	80 83       	st	Z, r24
	// this is better for motors as it ensures an even waveform
	// note, however, that fast pwm mode can achieve a frequency of up
	// 8 MHz (with a 16 MHz clock) at 50% duty cycle

	// set timer 1 prescale factor to 64
	sbi(TCCR1B, CS11);
 4b0:	e1 e8       	ldi	r30, 0x81	; 129
 4b2:	f0 e0       	ldi	r31, 0x00	; 0
 4b4:	80 81       	ld	r24, Z
 4b6:	82 60       	ori	r24, 0x02	; 2
 4b8:	80 83       	st	Z, r24
	sbi(TCCR1B, CS10);
 4ba:	80 81       	ld	r24, Z
 4bc:	81 60       	ori	r24, 0x01	; 1
 4be:	80 83       	st	Z, r24
	// put timer 1 in 8-bit phase correct pwm mode
	sbi(TCCR1A, WGM10);
 4c0:	e0 e8       	ldi	r30, 0x80	; 128
 4c2:	f0 e0       	ldi	r31, 0x00	; 0
 4c4:	80 81       	ld	r24, Z
 4c6:	81 60       	ori	r24, 0x01	; 1
 4c8:	80 83       	st	Z, r24

	// set timer 2 prescale factor to 64
#if defined(__AVR_ATmega8__)
	sbi(TCCR2, CS22);
#else
	sbi(TCCR2B, CS22);
 4ca:	e1 eb       	ldi	r30, 0xB1	; 177
 4cc:	f0 e0       	ldi	r31, 0x00	; 0
 4ce:	80 81       	ld	r24, Z
 4d0:	84 60       	ori	r24, 0x04	; 4
 4d2:	80 83       	st	Z, r24
#endif
	// configure timer 2 for phase correct pwm (8-bit)
#if defined(__AVR_ATmega8__)
	sbi(TCCR2, WGM20);
#else
	sbi(TCCR2A, WGM20);
 4d4:	e0 eb       	ldi	r30, 0xB0	; 176
 4d6:	f0 e0       	ldi	r31, 0x00	; 0
 4d8:	80 81       	ld	r24, Z
 4da:	81 60       	ori	r24, 0x01	; 1
 4dc:	80 83       	st	Z, r24

	// set a2d prescale factor to 128
	// 16 MHz / 128 = 125 KHz, inside the desired 50-200 KHz range.
	// XXX: this will not work properly for other clock speeds, and
	// this code should use F_CPU to determine the prescale factor.
	sbi(ADCSRA, ADPS2);
 4de:	ea e7       	ldi	r30, 0x7A	; 122
 4e0:	f0 e0       	ldi	r31, 0x00	; 0
 4e2:	80 81       	ld	r24, Z
 4e4:	84 60       	ori	r24, 0x04	; 4
 4e6:	80 83       	st	Z, r24
	sbi(ADCSRA, ADPS1);
 4e8:	80 81       	ld	r24, Z
 4ea:	82 60       	ori	r24, 0x02	; 2
 4ec:	80 83       	st	Z, r24
	sbi(ADCSRA, ADPS0);
 4ee:	80 81       	ld	r24, Z
 4f0:	81 60       	ori	r24, 0x01	; 1
 4f2:	80 83       	st	Z, r24

	// enable a2d conversions
	sbi(ADCSRA, ADEN);
 4f4:	80 81       	ld	r24, Z
 4f6:	80 68       	ori	r24, 0x80	; 128
 4f8:	80 83       	st	Z, r24
	// here so they can be used as normal digital i/o; they will be
	// reconnected in Serial.begin()
#if defined(__AVR_ATmega8__)
	UCSRB = 0;
#else
	UCSR0B = 0;
 4fa:	10 92 c1 00 	sts	0x00C1, r1
#endif
 4fe:	08 95       	ret

00000500 <analogReference>:
void analogReference(uint8_t mode)
{
	// can't actually set the register here because the default setting
	// will connect AVCC and the AREF pin, which would cause a short if
	// there's something connected to AREF.
	analog_reference = mode;
 500:	80 93 00 02 	sts	0x0200, r24
}
 504:	08 95       	ret

00000506 <analogRead>:
	uint8_t low, high;

	// set the analog reference (high two bits of ADMUX) and select the
	// channel (low 4 bits).  this also sets ADLAR (left-adjust result)
	// to 0 (the default).
	ADMUX = (analog_reference << 6) | (pin & 0x0f);
 506:	8f 70       	andi	r24, 0x0F	; 15
 508:	90 91 00 02 	lds	r25, 0x0200
 50c:	92 95       	swap	r25
 50e:	99 0f       	add	r25, r25
 510:	99 0f       	add	r25, r25
 512:	90 7c       	andi	r25, 0xC0	; 192
 514:	98 2b       	or	r25, r24
 516:	90 93 7c 00 	sts	0x007C, r25

	// without a delay, we seem to read from the wrong channel
	//delay(1);

	// start the conversion
	sbi(ADCSRA, ADSC);
 51a:	80 91 7a 00 	lds	r24, 0x007A
 51e:	80 64       	ori	r24, 0x40	; 64
 520:	80 93 7a 00 	sts	0x007A, r24

	// ADSC is cleared when the conversion finishes
	while (bit_is_set(ADCSRA, ADSC));
 524:	80 91 7a 00 	lds	r24, 0x007A
 528:	86 fd       	sbrc	r24, 6
 52a:	fc cf       	rjmp	.-8      	; 0x524 <analogRead+0x1e>

	// we have to read ADCL first; doing so locks both ADCL
	// and ADCH until ADCH is read.  reading ADCL second would
	// cause the results of each conversion to be discarded,
	// as ADCL and ADCH would be locked when it completed.
	low = ADCL;
 52c:	20 91 78 00 	lds	r18, 0x0078
	high = ADCH;
 530:	40 91 79 00 	lds	r20, 0x0079
 534:	94 2f       	mov	r25, r20
 536:	80 e0       	ldi	r24, 0x00	; 0
 538:	30 e0       	ldi	r19, 0x00	; 0
 53a:	28 2b       	or	r18, r24
 53c:	39 2b       	or	r19, r25

	// combine the two bytes
	return (high << 8) | low;
}
 53e:	c9 01       	movw	r24, r18
 540:	08 95       	ret

00000542 <analogWrite>:
// Right now, PWM output only works on the pins with
// hardware support.  These are defined in the appropriate
// pins_*.c file.  For the rest of the pins, we default
// to digital output.
void analogWrite(uint8_t pin, int val)
{
 542:	1f 93       	push	r17
 544:	cf 93       	push	r28
 546:	df 93       	push	r29
 548:	18 2f       	mov	r17, r24
 54a:	eb 01       	movw	r28, r22
	// We need to make sure the PWM output is enabled for those pins
	// that support it, as we turn it off when digitally reading or
	// writing with them.  Also, make sure the pin is in output mode
	// for consistenty with Wiring, which doesn't require a pinMode
	// call for the analog output pins.
	pinMode(pin, OUTPUT);
 54c:	61 e0       	ldi	r22, 0x01	; 1
 54e:	0e 94 07 03 	call	0x60e	; 0x60e <pinMode>
	
	if (digitalPinToTimer(pin) == TIMER1A) {
 552:	e1 2f       	mov	r30, r17
 554:	f0 e0       	ldi	r31, 0x00	; 0
 556:	e4 59       	subi	r30, 0x94	; 148
 558:	fe 4f       	sbci	r31, 0xFE	; 254
 55a:	84 91       	lpm	r24, Z+
 55c:	83 30       	cpi	r24, 0x03	; 3
 55e:	a1 f0       	breq	.+40     	; 0x588 <analogWrite+0x46>
		// connect pwm to pin on timer 1, channel A
		sbi(TCCR1A, COM1A1);
		// set pwm duty
		OCR1A = val;
	} else if (digitalPinToTimer(pin) == TIMER1B) {
 560:	84 30       	cpi	r24, 0x04	; 4
 562:	f9 f0       	breq	.+62     	; 0x5a2 <analogWrite+0x60>
		// connect pwm to pin on timer 2, channel B
		sbi(TCCR2, COM21);
		// set pwm duty
		OCR2 = val;
#else
	} else if (digitalPinToTimer(pin) == TIMER0A) {
 564:	81 30       	cpi	r24, 0x01	; 1
 566:	51 f1       	breq	.+84     	; 0x5bc <analogWrite+0x7a>
			// connect pwm to pin on timer 0, channel A
			sbi(TCCR0A, COM0A1);
			// set pwm duty
			OCR0A = val;      
		}
	} else if (digitalPinToTimer(pin) == TIMER0B) {
 568:	82 30       	cpi	r24, 0x02	; 2
 56a:	09 f4       	brne	.+2      	; 0x56e <analogWrite+0x2c>
 56c:	41 c0       	rjmp	.+130    	; 0x5f0 <analogWrite+0xae>
			// connect pwm to pin on timer 0, channel B
			sbi(TCCR0A, COM0B1);
			// set pwm duty
			OCR0B = val;
		}
	} else if (digitalPinToTimer(pin) == TIMER2A) {
 56e:	86 30       	cpi	r24, 0x06	; 6
 570:	79 f1       	breq	.+94     	; 0x5d0 <analogWrite+0x8e>
		// connect pwm to pin on timer 2, channel A
		sbi(TCCR2A, COM2A1);
		// set pwm duty
		OCR2A = val;	
	} else if (digitalPinToTimer(pin) == TIMER2B) {
 572:	87 30       	cpi	r24, 0x07	; 7
 574:	09 f4       	brne	.+2      	; 0x578 <analogWrite+0x36>
 576:	43 c0       	rjmp	.+134    	; 0x5fe <analogWrite+0xbc>
		// connect pwm to pin on timer 5, channel B
		sbi(TCCR5A, COM5B1);
		// set pwm duty
		OCR5B = val;
#endif
	} else if (val < 128)
 578:	c0 38       	cpi	r28, 0x80	; 128
 57a:	d1 05       	cpc	r29, r1
 57c:	8c f1       	brlt	.+98     	; 0x5e0 <analogWrite+0x9e>
		digitalWrite(pin, LOW);
	else
		digitalWrite(pin, HIGH);
 57e:	81 2f       	mov	r24, r17
 580:	61 e0       	ldi	r22, 0x01	; 1
 582:	0e 94 27 03 	call	0x64e	; 0x64e <digitalWrite>
 586:	09 c0       	rjmp	.+18     	; 0x59a <analogWrite+0x58>
	// call for the analog output pins.
	pinMode(pin, OUTPUT);
	
	if (digitalPinToTimer(pin) == TIMER1A) {
		// connect pwm to pin on timer 1, channel A
		sbi(TCCR1A, COM1A1);
 588:	80 91 80 00 	lds	r24, 0x0080
 58c:	80 68       	ori	r24, 0x80	; 128
 58e:	80 93 80 00 	sts	0x0080, r24
		// set pwm duty
		OCR1A = val;
 592:	d0 93 89 00 	sts	0x0089, r29
 596:	c0 93 88 00 	sts	0x0088, r28
#endif
	} else if (val < 128)
		digitalWrite(pin, LOW);
	else
		digitalWrite(pin, HIGH);
}
 59a:	df 91       	pop	r29
 59c:	cf 91       	pop	r28
 59e:	1f 91       	pop	r17
 5a0:	08 95       	ret
		sbi(TCCR1A, COM1A1);
		// set pwm duty
		OCR1A = val;
	} else if (digitalPinToTimer(pin) == TIMER1B) {
		// connect pwm to pin on timer 1, channel B
		sbi(TCCR1A, COM1B1);
 5a2:	80 91 80 00 	lds	r24, 0x0080
 5a6:	80 62       	ori	r24, 0x20	; 32
 5a8:	80 93 80 00 	sts	0x0080, r24
		// set pwm duty
		OCR1B = val;
 5ac:	d0 93 8b 00 	sts	0x008B, r29
 5b0:	c0 93 8a 00 	sts	0x008A, r28
#endif
	} else if (val < 128)
		digitalWrite(pin, LOW);
	else
		digitalWrite(pin, HIGH);
}
 5b4:	df 91       	pop	r29
 5b6:	cf 91       	pop	r28
 5b8:	1f 91       	pop	r17
 5ba:	08 95       	ret
		sbi(TCCR2, COM21);
		// set pwm duty
		OCR2 = val;
#else
	} else if (digitalPinToTimer(pin) == TIMER0A) {
		if (val == 0) {
 5bc:	20 97       	sbiw	r28, 0x00	; 0
 5be:	81 f0       	breq	.+32     	; 0x5e0 <analogWrite+0x9e>
			digitalWrite(pin, LOW);
		} else {
			// connect pwm to pin on timer 0, channel A
			sbi(TCCR0A, COM0A1);
 5c0:	84 b5       	in	r24, 0x24	; 36
 5c2:	80 68       	ori	r24, 0x80	; 128
 5c4:	84 bd       	out	0x24, r24	; 36
			// set pwm duty
			OCR0A = val;      
 5c6:	c7 bd       	out	0x27, r28	; 39
#endif
	} else if (val < 128)
		digitalWrite(pin, LOW);
	else
		digitalWrite(pin, HIGH);
}
 5c8:	df 91       	pop	r29
 5ca:	cf 91       	pop	r28
 5cc:	1f 91       	pop	r17
 5ce:	08 95       	ret
			// set pwm duty
			OCR0B = val;
		}
	} else if (digitalPinToTimer(pin) == TIMER2A) {
		// connect pwm to pin on timer 2, channel A
		sbi(TCCR2A, COM2A1);
 5d0:	80 91 b0 00 	lds	r24, 0x00B0
 5d4:	80 68       	ori	r24, 0x80	; 128
 5d6:	80 93 b0 00 	sts	0x00B0, r24
		// set pwm duty
		OCR2A = val;	
 5da:	c0 93 b3 00 	sts	0x00B3, r28
 5de:	dd cf       	rjmp	.-70     	; 0x59a <analogWrite+0x58>
		sbi(TCCR5A, COM5B1);
		// set pwm duty
		OCR5B = val;
#endif
	} else if (val < 128)
		digitalWrite(pin, LOW);
 5e0:	81 2f       	mov	r24, r17
 5e2:	60 e0       	ldi	r22, 0x00	; 0
 5e4:	0e 94 27 03 	call	0x64e	; 0x64e <digitalWrite>
	else
		digitalWrite(pin, HIGH);
}
 5e8:	df 91       	pop	r29
 5ea:	cf 91       	pop	r28
 5ec:	1f 91       	pop	r17
 5ee:	08 95       	ret
			sbi(TCCR0A, COM0A1);
			// set pwm duty
			OCR0A = val;      
		}
	} else if (digitalPinToTimer(pin) == TIMER0B) {
		if (val == 0) {
 5f0:	20 97       	sbiw	r28, 0x00	; 0
 5f2:	b1 f3       	breq	.-20     	; 0x5e0 <analogWrite+0x9e>
			digitalWrite(pin, LOW);
		} else {
			// connect pwm to pin on timer 0, channel B
			sbi(TCCR0A, COM0B1);
 5f4:	84 b5       	in	r24, 0x24	; 36
 5f6:	80 62       	ori	r24, 0x20	; 32
 5f8:	84 bd       	out	0x24, r24	; 36
			// set pwm duty
			OCR0B = val;
 5fa:	c8 bd       	out	0x28, r28	; 40
 5fc:	ce cf       	rjmp	.-100    	; 0x59a <analogWrite+0x58>
		sbi(TCCR2A, COM2A1);
		// set pwm duty
		OCR2A = val;	
	} else if (digitalPinToTimer(pin) == TIMER2B) {
		// connect pwm to pin on timer 2, channel B
		sbi(TCCR2A, COM2B1);
 5fe:	80 91 b0 00 	lds	r24, 0x00B0
 602:	80 62       	ori	r24, 0x20	; 32
 604:	80 93 b0 00 	sts	0x00B0, r24
		// set pwm duty
		OCR2B = val;
 608:	c0 93 b4 00 	sts	0x00B4, r28
 60c:	c6 cf       	rjmp	.-116    	; 0x59a <analogWrite+0x58>

0000060e <pinMode>:
#include "wiring_private.h"
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
	uint8_t bit = digitalPinToBitMask(pin);
 60e:	28 2f       	mov	r18, r24
 610:	30 e0       	ldi	r19, 0x00	; 0
 612:	c9 01       	movw	r24, r18
 614:	8c 5c       	subi	r24, 0xCC	; 204
 616:	9e 4f       	sbci	r25, 0xFE	; 254
 618:	fc 01       	movw	r30, r24
 61a:	94 91       	lpm	r25, Z+
	uint8_t port = digitalPinToPort(pin);
 61c:	24 50       	subi	r18, 0x04	; 4
 61e:	3f 4f       	sbci	r19, 0xFF	; 255
 620:	f9 01       	movw	r30, r18
 622:	84 91       	lpm	r24, Z+
	volatile uint8_t *reg;

	if (port == NOT_A_PIN) return;
 624:	88 23       	and	r24, r24
 626:	69 f0       	breq	.+26     	; 0x642 <pinMode+0x34>

	// JWS: can I let the optimizer do this?
	reg = portModeRegister(port);
 628:	e8 2f       	mov	r30, r24
 62a:	f0 e0       	ldi	r31, 0x00	; 0
 62c:	ee 0f       	add	r30, r30
 62e:	ff 1f       	adc	r31, r31
 630:	e4 53       	subi	r30, 0x34	; 52
 632:	ff 4f       	sbci	r31, 0xFF	; 255
 634:	a5 91       	lpm	r26, Z+
 636:	b4 91       	lpm	r27, Z+

	if (mode == INPUT) *reg &= ~bit;
 638:	66 23       	and	r22, r22
 63a:	21 f0       	breq	.+8      	; 0x644 <pinMode+0x36>
	else *reg |= bit;
 63c:	8c 91       	ld	r24, X
 63e:	89 2b       	or	r24, r25
 640:	8c 93       	st	X, r24
 642:	08 95       	ret
	if (port == NOT_A_PIN) return;

	// JWS: can I let the optimizer do this?
	reg = portModeRegister(port);

	if (mode == INPUT) *reg &= ~bit;
 644:	8c 91       	ld	r24, X
 646:	90 95       	com	r25
 648:	89 23       	and	r24, r25
 64a:	8c 93       	st	X, r24
 64c:	08 95       	ret

0000064e <digitalWrite>:
#endif
}

void digitalWrite(uint8_t pin, uint8_t val)
{
	uint8_t timer = digitalPinToTimer(pin);
 64e:	48 2f       	mov	r20, r24
 650:	50 e0       	ldi	r21, 0x00	; 0
 652:	ca 01       	movw	r24, r20
 654:	84 59       	subi	r24, 0x94	; 148
 656:	9e 4f       	sbci	r25, 0xFE	; 254
 658:	fc 01       	movw	r30, r24
 65a:	24 91       	lpm	r18, Z+
	uint8_t bit = digitalPinToBitMask(pin);
 65c:	ca 01       	movw	r24, r20
 65e:	8c 5c       	subi	r24, 0xCC	; 204
 660:	9e 4f       	sbci	r25, 0xFE	; 254
 662:	fc 01       	movw	r30, r24
 664:	94 91       	lpm	r25, Z+
	uint8_t port = digitalPinToPort(pin);
 666:	44 50       	subi	r20, 0x04	; 4
 668:	5f 4f       	sbci	r21, 0xFF	; 255
 66a:	fa 01       	movw	r30, r20
 66c:	34 91       	lpm	r19, Z+
	volatile uint8_t *out;

	if (port == NOT_A_PIN) return;
 66e:	33 23       	and	r19, r19
 670:	c1 f0       	breq	.+48     	; 0x6a2 <digitalWrite+0x54>

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
 672:	22 23       	and	r18, r18
 674:	49 f0       	breq	.+18     	; 0x688 <digitalWrite+0x3a>
// each digitalread or write.
//
static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
static inline void turnOffPWM(uint8_t timer)
{
	if (timer == TIMER1A) cbi(TCCR1A, COM1A1);
 676:	23 30       	cpi	r18, 0x03	; 3
 678:	d1 f0       	breq	.+52     	; 0x6ae <digitalWrite+0x60>
	if (timer == TIMER1B) cbi(TCCR1A, COM1B1);
 67a:	24 30       	cpi	r18, 0x04	; 4
 67c:	f1 f0       	breq	.+60     	; 0x6ba <digitalWrite+0x6c>

#if defined(__AVR_ATmega8__)
	if (timer == TIMER2) cbi(TCCR2, COM21);
#else
	if (timer == TIMER0A) cbi(TCCR0A, COM0A1);
 67e:	21 30       	cpi	r18, 0x01	; 1
 680:	11 f5       	brne	.+68     	; 0x6c6 <digitalWrite+0x78>
 682:	84 b5       	in	r24, 0x24	; 36
 684:	8f 77       	andi	r24, 0x7F	; 127
 686:	84 bd       	out	0x24, r24	; 36

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);

	out = portOutputRegister(port);
 688:	e3 2f       	mov	r30, r19
 68a:	f0 e0       	ldi	r31, 0x00	; 0
 68c:	ee 0f       	add	r30, r30
 68e:	ff 1f       	adc	r31, r31
 690:	e4 52       	subi	r30, 0x24	; 36
 692:	ff 4f       	sbci	r31, 0xFF	; 255
 694:	a5 91       	lpm	r26, Z+
 696:	b4 91       	lpm	r27, Z+

	if (val == LOW) *out &= ~bit;
 698:	66 23       	and	r22, r22
 69a:	21 f0       	breq	.+8      	; 0x6a4 <digitalWrite+0x56>
	else *out |= bit;
 69c:	8c 91       	ld	r24, X
 69e:	89 2b       	or	r24, r25
 6a0:	8c 93       	st	X, r24
 6a2:	08 95       	ret
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);

	out = portOutputRegister(port);

	if (val == LOW) *out &= ~bit;
 6a4:	8c 91       	ld	r24, X
 6a6:	90 95       	com	r25
 6a8:	89 23       	and	r24, r25
 6aa:	8c 93       	st	X, r24
 6ac:	08 95       	ret
// each digitalread or write.
//
static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
static inline void turnOffPWM(uint8_t timer)
{
	if (timer == TIMER1A) cbi(TCCR1A, COM1A1);
 6ae:	80 91 80 00 	lds	r24, 0x0080
 6b2:	8f 77       	andi	r24, 0x7F	; 127
 6b4:	80 93 80 00 	sts	0x0080, r24
 6b8:	e7 cf       	rjmp	.-50     	; 0x688 <digitalWrite+0x3a>
	if (timer == TIMER1B) cbi(TCCR1A, COM1B1);
 6ba:	80 91 80 00 	lds	r24, 0x0080
 6be:	8f 7d       	andi	r24, 0xDF	; 223
 6c0:	80 93 80 00 	sts	0x0080, r24
 6c4:	e1 cf       	rjmp	.-62     	; 0x688 <digitalWrite+0x3a>

#if defined(__AVR_ATmega8__)
	if (timer == TIMER2) cbi(TCCR2, COM21);
#else
	if (timer == TIMER0A) cbi(TCCR0A, COM0A1);
	if (timer == TIMER0B) cbi(TCCR0A, COM0B1);
 6c6:	22 30       	cpi	r18, 0x02	; 2
 6c8:	21 f4       	brne	.+8      	; 0x6d2 <digitalWrite+0x84>
 6ca:	84 b5       	in	r24, 0x24	; 36
 6cc:	8f 7d       	andi	r24, 0xDF	; 223
 6ce:	84 bd       	out	0x24, r24	; 36
 6d0:	db cf       	rjmp	.-74     	; 0x688 <digitalWrite+0x3a>
	if (timer == TIMER2A) cbi(TCCR2A, COM2A1);
 6d2:	26 30       	cpi	r18, 0x06	; 6
 6d4:	31 f4       	brne	.+12     	; 0x6e2 <digitalWrite+0x94>
 6d6:	80 91 b0 00 	lds	r24, 0x00B0
 6da:	8f 77       	andi	r24, 0x7F	; 127
 6dc:	80 93 b0 00 	sts	0x00B0, r24
 6e0:	d3 cf       	rjmp	.-90     	; 0x688 <digitalWrite+0x3a>
	if (timer == TIMER2B) cbi(TCCR2A, COM2B1);
 6e2:	27 30       	cpi	r18, 0x07	; 7
 6e4:	89 f6       	brne	.-94     	; 0x688 <digitalWrite+0x3a>
 6e6:	80 91 b0 00 	lds	r24, 0x00B0
 6ea:	8f 7d       	andi	r24, 0xDF	; 223
 6ec:	80 93 b0 00 	sts	0x00B0, r24
 6f0:	cb cf       	rjmp	.-106    	; 0x688 <digitalWrite+0x3a>

000006f2 <digitalRead>:
	else *out |= bit;
}

int digitalRead(uint8_t pin)
{
	uint8_t timer = digitalPinToTimer(pin);
 6f2:	68 2f       	mov	r22, r24
 6f4:	70 e0       	ldi	r23, 0x00	; 0
 6f6:	cb 01       	movw	r24, r22
 6f8:	84 59       	subi	r24, 0x94	; 148
 6fa:	9e 4f       	sbci	r25, 0xFE	; 254
 6fc:	fc 01       	movw	r30, r24
 6fe:	24 91       	lpm	r18, Z+
	uint8_t bit = digitalPinToBitMask(pin);
 700:	cb 01       	movw	r24, r22
 702:	8c 5c       	subi	r24, 0xCC	; 204
 704:	9e 4f       	sbci	r25, 0xFE	; 254
 706:	fc 01       	movw	r30, r24
 708:	44 91       	lpm	r20, Z+
	uint8_t port = digitalPinToPort(pin);
 70a:	64 50       	subi	r22, 0x04	; 4
 70c:	7f 4f       	sbci	r23, 0xFF	; 255
 70e:	fb 01       	movw	r30, r22
 710:	94 91       	lpm	r25, Z+

	if (port == NOT_A_PIN) return LOW;
 712:	99 23       	and	r25, r25
 714:	f9 f0       	breq	.+62     	; 0x754 <digitalRead+0x62>

	// If the pin that support PWM output, we need to turn it off
	// before getting a digital reading.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
 716:	22 23       	and	r18, r18
 718:	49 f0       	breq	.+18     	; 0x72c <digitalRead+0x3a>
// each digitalread or write.
//
static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
static inline void turnOffPWM(uint8_t timer)
{
	if (timer == TIMER1A) cbi(TCCR1A, COM1A1);
 71a:	23 30       	cpi	r18, 0x03	; 3
 71c:	f9 f0       	breq	.+62     	; 0x75c <digitalRead+0x6a>
	if (timer == TIMER1B) cbi(TCCR1A, COM1B1);
 71e:	24 30       	cpi	r18, 0x04	; 4
 720:	19 f1       	breq	.+70     	; 0x768 <digitalRead+0x76>

#if defined(__AVR_ATmega8__)
	if (timer == TIMER2) cbi(TCCR2, COM21);
#else
	if (timer == TIMER0A) cbi(TCCR0A, COM0A1);
 722:	21 30       	cpi	r18, 0x01	; 1
 724:	39 f5       	brne	.+78     	; 0x774 <digitalRead+0x82>
 726:	84 b5       	in	r24, 0x24	; 36
 728:	8f 77       	andi	r24, 0x7F	; 127
 72a:	84 bd       	out	0x24, r24	; 36

	// If the pin that support PWM output, we need to turn it off
	// before getting a digital reading.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);

	if (*portInputRegister(port) & bit) return HIGH;
 72c:	89 2f       	mov	r24, r25
 72e:	90 e0       	ldi	r25, 0x00	; 0
 730:	88 0f       	add	r24, r24
 732:	99 1f       	adc	r25, r25
 734:	84 51       	subi	r24, 0x14	; 20
 736:	9f 4f       	sbci	r25, 0xFF	; 255
 738:	fc 01       	movw	r30, r24
 73a:	a5 91       	lpm	r26, Z+
 73c:	b4 91       	lpm	r27, Z+
 73e:	8c 91       	ld	r24, X
 740:	20 e0       	ldi	r18, 0x00	; 0
 742:	30 e0       	ldi	r19, 0x00	; 0
 744:	84 23       	and	r24, r20
 746:	11 f4       	brne	.+4      	; 0x74c <digitalRead+0x5a>
	return LOW;
}
 748:	c9 01       	movw	r24, r18
 74a:	08 95       	ret

	// If the pin that support PWM output, we need to turn it off
	// before getting a digital reading.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);

	if (*portInputRegister(port) & bit) return HIGH;
 74c:	21 e0       	ldi	r18, 0x01	; 1
 74e:	30 e0       	ldi	r19, 0x00	; 0
	return LOW;
}
 750:	c9 01       	movw	r24, r18
 752:	08 95       	ret
{
	uint8_t timer = digitalPinToTimer(pin);
	uint8_t bit = digitalPinToBitMask(pin);
	uint8_t port = digitalPinToPort(pin);

	if (port == NOT_A_PIN) return LOW;
 754:	20 e0       	ldi	r18, 0x00	; 0
 756:	30 e0       	ldi	r19, 0x00	; 0
	// before getting a digital reading.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);

	if (*portInputRegister(port) & bit) return HIGH;
	return LOW;
}
 758:	c9 01       	movw	r24, r18
 75a:	08 95       	ret
// each digitalread or write.
//
static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
static inline void turnOffPWM(uint8_t timer)
{
	if (timer == TIMER1A) cbi(TCCR1A, COM1A1);
 75c:	80 91 80 00 	lds	r24, 0x0080
 760:	8f 77       	andi	r24, 0x7F	; 127
 762:	80 93 80 00 	sts	0x0080, r24
 766:	e2 cf       	rjmp	.-60     	; 0x72c <digitalRead+0x3a>
	if (timer == TIMER1B) cbi(TCCR1A, COM1B1);
 768:	80 91 80 00 	lds	r24, 0x0080
 76c:	8f 7d       	andi	r24, 0xDF	; 223
 76e:	80 93 80 00 	sts	0x0080, r24
 772:	dc cf       	rjmp	.-72     	; 0x72c <digitalRead+0x3a>

#if defined(__AVR_ATmega8__)
	if (timer == TIMER2) cbi(TCCR2, COM21);
#else
	if (timer == TIMER0A) cbi(TCCR0A, COM0A1);
	if (timer == TIMER0B) cbi(TCCR0A, COM0B1);
 774:	22 30       	cpi	r18, 0x02	; 2
 776:	21 f4       	brne	.+8      	; 0x780 <digitalRead+0x8e>
 778:	84 b5       	in	r24, 0x24	; 36
 77a:	8f 7d       	andi	r24, 0xDF	; 223
 77c:	84 bd       	out	0x24, r24	; 36
 77e:	d6 cf       	rjmp	.-84     	; 0x72c <digitalRead+0x3a>
	if (timer == TIMER2A) cbi(TCCR2A, COM2A1);
 780:	26 30       	cpi	r18, 0x06	; 6
 782:	31 f4       	brne	.+12     	; 0x790 <digitalRead+0x9e>
 784:	80 91 b0 00 	lds	r24, 0x00B0
 788:	8f 77       	andi	r24, 0x7F	; 127
 78a:	80 93 b0 00 	sts	0x00B0, r24
 78e:	ce cf       	rjmp	.-100    	; 0x72c <digitalRead+0x3a>
	if (timer == TIMER2B) cbi(TCCR2A, COM2B1);
 790:	27 30       	cpi	r18, 0x07	; 7
 792:	61 f6       	brne	.-104    	; 0x72c <digitalRead+0x3a>
 794:	80 91 b0 00 	lds	r24, 0x00B0
 798:	8f 7d       	andi	r24, 0xDF	; 223
 79a:	80 93 b0 00 	sts	0x00B0, r24
 79e:	c6 cf       	rjmp	.-116    	; 0x72c <digitalRead+0x3a>

000007a0 <pulseIn>:
/* Measures the length (in microseconds) of a pulse on the pin; state is HIGH
 * or LOW, the type of pulse to measure.  Works on pulses from 2-3 microseconds
 * to 3 minutes in length, but must be called at least a few dozen microseconds
 * before the start of the pulse. */
unsigned long pulseIn(uint8_t pin, uint8_t state, unsigned long timeout)
{
 7a0:	df 92       	push	r13
 7a2:	ef 92       	push	r14
 7a4:	ff 92       	push	r15
 7a6:	0f 93       	push	r16
 7a8:	1f 93       	push	r17
	// cache the port and bit of the pin in order to speed up the
	// pulse width measuring loop and achieve finer resolution.  calling
	// digitalRead() instead yields much coarser resolution.
	uint8_t bit = digitalPinToBitMask(pin);
 7aa:	a8 2f       	mov	r26, r24
 7ac:	b0 e0       	ldi	r27, 0x00	; 0
 7ae:	cd 01       	movw	r24, r26
 7b0:	8c 5c       	subi	r24, 0xCC	; 204
 7b2:	9e 4f       	sbci	r25, 0xFE	; 254
 7b4:	fc 01       	movw	r30, r24
 7b6:	d4 90       	lpm	r13, Z+
	uint8_t port = digitalPinToPort(pin);
 7b8:	a4 50       	subi	r26, 0x04	; 4
 7ba:	bf 4f       	sbci	r27, 0xFF	; 255
 7bc:	fd 01       	movw	r30, r26
 7be:	84 91       	lpm	r24, Z+
	uint8_t stateMask = (state ? bit : 0);
 7c0:	66 23       	and	r22, r22
 7c2:	a1 f5       	brne	.+104    	; 0x82c <pulseIn+0x8c>
 7c4:	90 e0       	ldi	r25, 0x00	; 0
	unsigned long width = 0; // keep initialization out of time critical area
	
	// convert the timeout from microseconds to a number of times through
	// the initial loop; it takes 16 clock cycles per iteration.
	unsigned long numloops = 0;
	unsigned long maxloops = microsecondsToClockCycles(timeout) / 16;
 7c6:	6f ef       	ldi	r22, 0xFF	; 255
 7c8:	e6 2e       	mov	r14, r22
 7ca:	6f ef       	ldi	r22, 0xFF	; 255
 7cc:	f6 2e       	mov	r15, r22
 7ce:	6f ef       	ldi	r22, 0xFF	; 255
 7d0:	06 2f       	mov	r16, r22
 7d2:	6f e0       	ldi	r22, 0x0F	; 15
 7d4:	16 2f       	mov	r17, r22
 7d6:	e2 22       	and	r14, r18
 7d8:	f3 22       	and	r15, r19
 7da:	04 23       	and	r16, r20
 7dc:	15 23       	and	r17, r21
 7de:	68 2f       	mov	r22, r24
 7e0:	70 e0       	ldi	r23, 0x00	; 0
 7e2:	66 0f       	add	r22, r22
 7e4:	77 1f       	adc	r23, r23
 7e6:	64 51       	subi	r22, 0x14	; 20
 7e8:	7f 4f       	sbci	r23, 0xFF	; 255
 7ea:	20 e0       	ldi	r18, 0x00	; 0
 7ec:	30 e0       	ldi	r19, 0x00	; 0
 7ee:	40 e0       	ldi	r20, 0x00	; 0
 7f0:	50 e0       	ldi	r21, 0x00	; 0
	
	// wait for any previous pulse to end
	while ((*portInputRegister(port) & bit) == stateMask)
 7f2:	fb 01       	movw	r30, r22
 7f4:	a5 91       	lpm	r26, Z+
 7f6:	b4 91       	lpm	r27, Z+
 7f8:	04 c0       	rjmp	.+8      	; 0x802 <pulseIn+0x62>
		if (numloops++ == maxloops)
 7fa:	2f 5f       	subi	r18, 0xFF	; 255
 7fc:	3f 4f       	sbci	r19, 0xFF	; 255
 7fe:	4f 4f       	sbci	r20, 0xFF	; 255
 800:	5f 4f       	sbci	r21, 0xFF	; 255
	// the initial loop; it takes 16 clock cycles per iteration.
	unsigned long numloops = 0;
	unsigned long maxloops = microsecondsToClockCycles(timeout) / 16;
	
	// wait for any previous pulse to end
	while ((*portInputRegister(port) & bit) == stateMask)
 802:	8c 91       	ld	r24, X
 804:	8d 21       	and	r24, r13
 806:	98 17       	cp	r25, r24
 808:	99 f4       	brne	.+38     	; 0x830 <pulseIn+0x90>
		if (numloops++ == maxloops)
 80a:	2e 15       	cp	r18, r14
 80c:	3f 05       	cpc	r19, r15
 80e:	40 07       	cpc	r20, r16
 810:	51 07       	cpc	r21, r17
 812:	99 f7       	brne	.-26     	; 0x7fa <pulseIn+0x5a>
	while ((*portInputRegister(port) & bit) != stateMask)
		if (numloops++ == maxloops)
			return 0;
	
	// wait for the pulse to stop
	while ((*portInputRegister(port) & bit) == stateMask)
 814:	20 e0       	ldi	r18, 0x00	; 0
 816:	30 e0       	ldi	r19, 0x00	; 0
 818:	40 e0       	ldi	r20, 0x00	; 0
 81a:	50 e0       	ldi	r21, 0x00	; 0
	// convert the reading to microseconds. The loop has been determined
	// to be 10 clock cycles long and have about 16 clocks between the edge
	// and the start of the loop. There will be some error introduced by
	// the interrupt handlers.
	return clockCyclesToMicroseconds(width * 10 + 16); 
}
 81c:	b9 01       	movw	r22, r18
 81e:	ca 01       	movw	r24, r20
 820:	1f 91       	pop	r17
 822:	0f 91       	pop	r16
 824:	ff 90       	pop	r15
 826:	ef 90       	pop	r14
 828:	df 90       	pop	r13
 82a:	08 95       	ret
	// cache the port and bit of the pin in order to speed up the
	// pulse width measuring loop and achieve finer resolution.  calling
	// digitalRead() instead yields much coarser resolution.
	uint8_t bit = digitalPinToBitMask(pin);
	uint8_t port = digitalPinToPort(pin);
	uint8_t stateMask = (state ? bit : 0);
 82c:	9d 2d       	mov	r25, r13
 82e:	cb cf       	rjmp	.-106    	; 0x7c6 <pulseIn+0x26>
	while ((*portInputRegister(port) & bit) == stateMask)
		if (numloops++ == maxloops)
			return 0;
	
	// wait for the pulse to start
	while ((*portInputRegister(port) & bit) != stateMask)
 830:	fb 01       	movw	r30, r22
 832:	a5 91       	lpm	r26, Z+
 834:	b4 91       	lpm	r27, Z+
 836:	04 c0       	rjmp	.+8      	; 0x840 <pulseIn+0xa0>
		if (numloops++ == maxloops)
 838:	2f 5f       	subi	r18, 0xFF	; 255
 83a:	3f 4f       	sbci	r19, 0xFF	; 255
 83c:	4f 4f       	sbci	r20, 0xFF	; 255
 83e:	5f 4f       	sbci	r21, 0xFF	; 255
	while ((*portInputRegister(port) & bit) == stateMask)
		if (numloops++ == maxloops)
			return 0;
	
	// wait for the pulse to start
	while ((*portInputRegister(port) & bit) != stateMask)
 840:	8c 91       	ld	r24, X
 842:	8d 21       	and	r24, r13
 844:	98 17       	cp	r25, r24
 846:	31 f0       	breq	.+12     	; 0x854 <pulseIn+0xb4>
		if (numloops++ == maxloops)
 848:	2e 15       	cp	r18, r14
 84a:	3f 05       	cpc	r19, r15
 84c:	40 07       	cpc	r20, r16
 84e:	51 07       	cpc	r21, r17
 850:	99 f7       	brne	.-26     	; 0x838 <pulseIn+0x98>
 852:	e0 cf       	rjmp	.-64     	; 0x814 <pulseIn+0x74>
			return 0;
	
	// wait for the pulse to stop
	while ((*portInputRegister(port) & bit) == stateMask)
 854:	8c 91       	ld	r24, X
 856:	8d 21       	and	r24, r13
 858:	98 17       	cp	r25, r24
 85a:	29 f5       	brne	.+74     	; 0x8a6 <pulseIn+0x106>
 85c:	20 e0       	ldi	r18, 0x00	; 0
 85e:	30 e0       	ldi	r19, 0x00	; 0
 860:	40 e0       	ldi	r20, 0x00	; 0
 862:	50 e0       	ldi	r21, 0x00	; 0
 864:	fb 01       	movw	r30, r22
 866:	a5 91       	lpm	r26, Z+
 868:	b4 91       	lpm	r27, Z+
		width++;
 86a:	2f 5f       	subi	r18, 0xFF	; 255
 86c:	3f 4f       	sbci	r19, 0xFF	; 255
 86e:	4f 4f       	sbci	r20, 0xFF	; 255
 870:	5f 4f       	sbci	r21, 0xFF	; 255
	while ((*portInputRegister(port) & bit) != stateMask)
		if (numloops++ == maxloops)
			return 0;
	
	// wait for the pulse to stop
	while ((*portInputRegister(port) & bit) == stateMask)
 872:	8c 91       	ld	r24, X
 874:	8d 21       	and	r24, r13
 876:	98 17       	cp	r25, r24
 878:	c1 f3       	breq	.-16     	; 0x86a <pulseIn+0xca>
 87a:	ca 01       	movw	r24, r20
 87c:	b9 01       	movw	r22, r18
 87e:	2a e0       	ldi	r18, 0x0A	; 10
 880:	30 e0       	ldi	r19, 0x00	; 0
 882:	40 e0       	ldi	r20, 0x00	; 0
 884:	50 e0       	ldi	r21, 0x00	; 0
 886:	0e 94 9e 04 	call	0x93c	; 0x93c <__mulsi3>
 88a:	9b 01       	movw	r18, r22
 88c:	ac 01       	movw	r20, r24
 88e:	20 5f       	subi	r18, 0xF0	; 240
 890:	3f 4f       	sbci	r19, 0xFF	; 255
 892:	4f 4f       	sbci	r20, 0xFF	; 255
 894:	5f 4f       	sbci	r21, 0xFF	; 255
 896:	84 e0       	ldi	r24, 0x04	; 4
 898:	56 95       	lsr	r21
 89a:	47 95       	ror	r20
 89c:	37 95       	ror	r19
 89e:	27 95       	ror	r18
 8a0:	8a 95       	dec	r24
 8a2:	d1 f7       	brne	.-12     	; 0x898 <pulseIn+0xf8>
 8a4:	bb cf       	rjmp	.-138    	; 0x81c <pulseIn+0x7c>
 8a6:	21 e0       	ldi	r18, 0x01	; 1
 8a8:	30 e0       	ldi	r19, 0x00	; 0
 8aa:	40 e0       	ldi	r20, 0x00	; 0
 8ac:	50 e0       	ldi	r21, 0x00	; 0
 8ae:	b6 cf       	rjmp	.-148    	; 0x81c <pulseIn+0x7c>

000008b0 <shiftOut>:
*/

#include "wiring_private.h"

void shiftOut(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder, byte val)
{
 8b0:	af 92       	push	r10
 8b2:	bf 92       	push	r11
 8b4:	df 92       	push	r13
 8b6:	ef 92       	push	r14
 8b8:	ff 92       	push	r15
 8ba:	0f 93       	push	r16
 8bc:	1f 93       	push	r17
 8be:	cf 93       	push	r28
 8c0:	df 93       	push	r29
 8c2:	d8 2e       	mov	r13, r24
 8c4:	f6 2e       	mov	r15, r22
 8c6:	e4 2e       	mov	r14, r20
 8c8:	c0 e0       	ldi	r28, 0x00	; 0
 8ca:	d0 e0       	ldi	r29, 0x00	; 0
 8cc:	02 2f       	mov	r16, r18
 8ce:	10 e0       	ldi	r17, 0x00	; 0

	for (i = 0; i < 8; i++)  {
		if (bitOrder == LSBFIRST)
			digitalWrite(dataPin, !!(val & (1 << i)));
		else	
			digitalWrite(dataPin, !!(val & (1 << (7 - i))));
 8d0:	87 e0       	ldi	r24, 0x07	; 7
 8d2:	a8 2e       	mov	r10, r24
 8d4:	b1 2c       	mov	r11, r1
 8d6:	17 c0       	rjmp	.+46     	; 0x906 <shiftOut+0x56>
{
	int i;

	for (i = 0; i < 8; i++)  {
		if (bitOrder == LSBFIRST)
			digitalWrite(dataPin, !!(val & (1 << i)));
 8d8:	b8 01       	movw	r22, r16
 8da:	0c 2e       	mov	r0, r28
 8dc:	02 c0       	rjmp	.+4      	; 0x8e2 <shiftOut+0x32>
 8de:	75 95       	asr	r23
 8e0:	67 95       	ror	r22
 8e2:	0a 94       	dec	r0
 8e4:	e2 f7       	brpl	.-8      	; 0x8de <shiftOut+0x2e>
 8e6:	61 70       	andi	r22, 0x01	; 1
 8e8:	8d 2d       	mov	r24, r13
 8ea:	0e 94 27 03 	call	0x64e	; 0x64e <digitalWrite>
		else	
			digitalWrite(dataPin, !!(val & (1 << (7 - i))));
			
		digitalWrite(clockPin, HIGH);
 8ee:	8f 2d       	mov	r24, r15
 8f0:	61 e0       	ldi	r22, 0x01	; 1
 8f2:	0e 94 27 03 	call	0x64e	; 0x64e <digitalWrite>
		digitalWrite(clockPin, LOW);		
 8f6:	8f 2d       	mov	r24, r15
 8f8:	60 e0       	ldi	r22, 0x00	; 0
 8fa:	0e 94 27 03 	call	0x64e	; 0x64e <digitalWrite>

void shiftOut(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder, byte val)
{
	int i;

	for (i = 0; i < 8; i++)  {
 8fe:	21 96       	adiw	r28, 0x01	; 1
 900:	c8 30       	cpi	r28, 0x08	; 8
 902:	d1 05       	cpc	r29, r1
 904:	89 f0       	breq	.+34     	; 0x928 <shiftOut+0x78>
		if (bitOrder == LSBFIRST)
 906:	ee 20       	and	r14, r14
 908:	39 f3       	breq	.-50     	; 0x8d8 <shiftOut+0x28>
			digitalWrite(dataPin, !!(val & (1 << i)));
		else	
			digitalWrite(dataPin, !!(val & (1 << (7 - i))));
 90a:	b5 01       	movw	r22, r10
 90c:	6c 1b       	sub	r22, r28
 90e:	7d 0b       	sbc	r23, r29
 910:	c8 01       	movw	r24, r16
 912:	02 c0       	rjmp	.+4      	; 0x918 <shiftOut+0x68>
 914:	95 95       	asr	r25
 916:	87 95       	ror	r24
 918:	6a 95       	dec	r22
 91a:	e2 f7       	brpl	.-8      	; 0x914 <shiftOut+0x64>
 91c:	bc 01       	movw	r22, r24
 91e:	61 70       	andi	r22, 0x01	; 1
 920:	8d 2d       	mov	r24, r13
 922:	0e 94 27 03 	call	0x64e	; 0x64e <digitalWrite>
 926:	e3 cf       	rjmp	.-58     	; 0x8ee <shiftOut+0x3e>
			
		digitalWrite(clockPin, HIGH);
		digitalWrite(clockPin, LOW);		
	}
}
 928:	df 91       	pop	r29
 92a:	cf 91       	pop	r28
 92c:	1f 91       	pop	r17
 92e:	0f 91       	pop	r16
 930:	ff 90       	pop	r15
 932:	ef 90       	pop	r14
 934:	df 90       	pop	r13
 936:	bf 90       	pop	r11
 938:	af 90       	pop	r10
 93a:	08 95       	ret

0000093c <__mulsi3>:
 93c:	62 9f       	mul	r22, r18
 93e:	d0 01       	movw	r26, r0
 940:	73 9f       	mul	r23, r19
 942:	f0 01       	movw	r30, r0
 944:	82 9f       	mul	r24, r18
 946:	e0 0d       	add	r30, r0
 948:	f1 1d       	adc	r31, r1
 94a:	64 9f       	mul	r22, r20
 94c:	e0 0d       	add	r30, r0
 94e:	f1 1d       	adc	r31, r1
 950:	92 9f       	mul	r25, r18
 952:	f0 0d       	add	r31, r0
 954:	83 9f       	mul	r24, r19
 956:	f0 0d       	add	r31, r0
 958:	74 9f       	mul	r23, r20
 95a:	f0 0d       	add	r31, r0
 95c:	65 9f       	mul	r22, r21
 95e:	f0 0d       	add	r31, r0
 960:	99 27       	eor	r25, r25
 962:	72 9f       	mul	r23, r18
 964:	b0 0d       	add	r27, r0
 966:	e1 1d       	adc	r30, r1
 968:	f9 1f       	adc	r31, r25
 96a:	63 9f       	mul	r22, r19
 96c:	b0 0d       	add	r27, r0
 96e:	e1 1d       	adc	r30, r1
 970:	f9 1f       	adc	r31, r25
 972:	bd 01       	movw	r22, r26
 974:	cf 01       	movw	r24, r30
 976:	11 24       	eor	r1, r1
 978:	08 95       	ret

0000097a <_exit>:
 97a:	f8 94       	cli

0000097c <__stop_program>:
 97c:	ff cf       	rjmp	.-2      	; 0x97c <__stop_program>
